% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/borg_guard.R
\name{borg_guard}
\alias{borg_guard}
\title{Guard Model Evaluation Against Information Reuse}
\usage{
borg_guard(
  data,
  train_idx,
  test_idx,
  mode = c("strict", "warn", "rewrite"),
  temporal_col = NULL,
  spatial_cols = NULL,
  group_col = NULL
)
}
\arguments{
\item{data}{A data.frame containing the full dataset.}

\item{train_idx}{Integer vector of training row indices.}

\item{test_idx}{Integer vector of test row indices.}

\item{mode}{Character string specifying enforcement mode:
\itemize{
\item \code{"strict"}: Block all violations, refuse to proceed
\item \code{"warn"}: Warn on violations but continue
\item \code{"rewrite"}: Automatically fix violations where possible
}}

\item{temporal_col}{Optional character string naming a timestamp column.
If provided, enables temporal ordering validation.}

\item{spatial_cols}{Optional character vector naming coordinate columns
(e.g., \code{c("longitude", "latitude")}). If provided, enables spatial
autocorrelation checks.}

\item{group_col}{Optional character string naming a grouping column.
If provided, enables group-level isolation checks.}
}
\value{
A \code{borg_context} object that can be used to wrap preprocessing
and evaluation calls. This object tracks all operations and validates them
against the train/test split.
}
\description{
\code{borg_guard()} wraps an evaluation workflow and enforces valid data handling.
It intercepts operations that would leak information from test to training
data and either blocks them (hard violations) or rewrites them (soft violations).
}
\details{
\code{borg_guard()} creates a guarded context for model evaluation. Within this
context, BORG:

\enumerate{
\item Validates the initial train/test split
\item Monitors preprocessing operations for data leakage
\item Enforces temporal ordering (if \code{temporal_col} specified)
\item Validates spatial block separation (if \code{spatial_cols} specified)
\item Ensures group isolation (if \code{group_col} specified)
}
}
\section{Enforcement Modes}{

\describe{
\item{strict}{Most conservative. Any detected violation causes an immediate
error. Use for production pipelines where validity is critical.}
\item{warn}{Permissive mode. Violations generate warnings but evaluation
proceeds. Use for exploratory analysis or legacy code auditing.}
\item{rewrite}{Automatic correction mode. BORG attempts to fix violations
(e.g., refitting preprocessing on train-only). Use when migrating
existing pipelines.}
}
}

\examples{
# The canonical failure: preprocessing before splitting
# This workflow produces inflated performance estimates:
#
#   data_scaled <- scale(full_data)
#   train <- data_scaled[1:800, ]
#   test <- data_scaled[801:1000, ]
#
# BORG blocks this pattern.

# Valid split (no overlap)
data <- data.frame(x = rnorm(100), y = rnorm(100))
ctx <- borg_guard(data, train_idx = 1:70, test_idx = 71:100)
print(ctx)

# Invalid split (overlap) - errors immediately
\dontrun{
ctx <- borg_guard(data, train_idx = 1:60, test_idx = 50:100)
# Error: BORG HARD VIOLATION: train_idx and test_idx overlap
}

# Grouped data - ensures no group appears in both splits
data$patient <- rep(1:10, each = 10)
ctx <- borg_guard(
  data,
  train_idx = 1:50,
  test_idx = 51:100,
  group_col = "patient"
)

# Temporal data - validates chronological ordering
data$date <- seq.Date(as.Date("2020-01-01"), by = "day", length.out = 100)
ctx <- borg_guard(
  data,
  train_idx = 1:70,
  test_idx = 71:100,
  temporal_col = "date"
)

}
\seealso{
\code{\link{borg_inspect}} for object-level inspection,
\code{\link{borg_validate}} for post-hoc workflow validation.
}
